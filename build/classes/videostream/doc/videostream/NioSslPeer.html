<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_74) on Tue Jun 21 15:11:23 CEST 2016 -->
<title>NioSslPeer</title>
<meta name="date" content="2016-06-21">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="NioSslPeer";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":6,"i10":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../videostream/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../videostream/NioSslClient.html" title="class in videostream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../videostream/NioSslServer.html" title="class in videostream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?videostream/NioSslPeer.html" target="_top">Frames</a></li>
<li><a href="NioSslPeer.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">videostream</div>
<h2 title="Class NioSslPeer" class="title">Class NioSslPeer</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>videostream.NioSslPeer</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../videostream/NioSslClient.html" title="class in videostream">NioSslClient</a>, <a href="../videostream/NioSslServer.html" title="class in videostream">NioSslServer</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">NioSslPeer</span>
extends java.lang.Object</pre>
<div class="block">A class that represents an SSL/TLS peer, and can be extended to create a
 client or a server.
 <p/>
 It makes use of the JSSE framework, and specifically the <code>SSLEngine</code>
 logic, which is described by Oracle as "an advanced API, not appropriate for
 casual use", since it requires the user to implement much of the
 communication establishment procedure himself. More information about it can
 be found here:
 http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#SSLEngine
 <p/>
 <a href="../videostream/NioSslPeer.html" title="class in videostream"><code>NioSslPeer</code></a> implements the handshake protocol, required to establish a
 connection between two peers, which is common for both client and server and
 provides the abstract <a href="../videostream/NioSslPeer.html#read-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-"><code>read(SocketChannel, SSLEngine)</code></a> and
 <code>NioSslPeer#write(SocketChannel, SSLEngine, String)</code> methods, that need
 to be implemented by the specific SSL/TLS peer that is going to extend this
 class.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.concurrent.ExecutorService</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#executor">executor</a></span></code>
<div class="block">Will be used to execute tasks that may emerge during handshake in
 parallel with the server's main thread.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#myAppData">myAppData</a></span></code>
<div class="block">Will contain this peer's application data in plaintext, that will be
 later encrypted using <code>SSLEngine.wrap(ByteBuffer, ByteBuffer)</code> and
 sent to the other peer.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#myNetData">myNetData</a></span></code>
<div class="block">Will contain this peer's encrypted data, that will be generated after
 <code>SSLEngine.wrap(ByteBuffer, ByteBuffer)</code> is applied on
 <a href="../videostream/NioSslPeer.html#myAppData"><code>myAppData</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#peerAppData">peerAppData</a></span></code>
<div class="block">Will contain the other peer's (decrypted) application data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#peerNetData">peerNetData</a></span></code>
<div class="block">Will contain the other peer's encrypted data.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#NioSslPeer--">NioSslPeer</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#closeConnection-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">closeConnection</a></span>(java.nio.channels.SocketChannel&nbsp;socketChannel,
               javax.net.ssl.SSLEngine&nbsp;engine)</code>
<div class="block">This method should be called when this peer wants to explicitly close the
 connection or when a close message has arrived from the other peer, in
 order to provide an orderly shutdown.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected javax.net.ssl.KeyManager[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#createKeyManagers-java.lang.String-java.lang.String-java.lang.String-">createKeyManagers</a></span>(java.lang.String&nbsp;filepath,
                 java.lang.String&nbsp;keystorePassword,
                 java.lang.String&nbsp;keyPassword)</code>
<div class="block">Creates the key managers required to initiate the <code>SSLContext</code>,
 using a JKS keystore as an input.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected javax.net.ssl.TrustManager[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#createTrustManagers-java.lang.String-java.lang.String-">createTrustManagers</a></span>(java.lang.String&nbsp;filepath,
                   java.lang.String&nbsp;keystorePassword)</code>
<div class="block">Creates the trust managers required to initiate the <code>SSLContext</code>,
 using a JKS keystore as an input.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#doHandshake-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">doHandshake</a></span>(java.nio.channels.SocketChannel&nbsp;socketChannel,
           javax.net.ssl.SSLEngine&nbsp;engine)</code>
<div class="block">Implements the handshake protocol between two peers, required for the
 establishment of the SSL/TLS connection.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#enlargeApplicationBuffer-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">enlargeApplicationBuffer</a></span>(javax.net.ssl.SSLEngine&nbsp;engine,
                        java.nio.ByteBuffer&nbsp;buffer)</code>&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#enlargeBuffer-java.nio.ByteBuffer-int-">enlargeBuffer</a></span>(java.nio.ByteBuffer&nbsp;buffer,
             int&nbsp;sessionProposedCapacity)</code>
<div class="block">Compares <code>sessionProposedCapacity<code> with buffer's capacity.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#enlargePacketBuffer-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">enlargePacketBuffer</a></span>(javax.net.ssl.SSLEngine&nbsp;engine,
                   java.nio.ByteBuffer&nbsp;buffer)</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected java.nio.ByteBuffer</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#handleBufferUnderflow-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">handleBufferUnderflow</a></span>(javax.net.ssl.SSLEngine&nbsp;engine,
                     java.nio.ByteBuffer&nbsp;buffer)</code>
<div class="block">Handles <code>SSLEngineResult.Status#BUFFER_UNDERFLOW</code>.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#handleEndOfStream-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">handleEndOfStream</a></span>(java.nio.channels.SocketChannel&nbsp;socketChannel,
                 javax.net.ssl.SSLEngine&nbsp;engine)</code>
<div class="block">In addition to orderly shutdowns, an unorderly shutdown may occur, when
 the transport link (socket channel) is severed before close messages are
 exchanged.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#read-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">read</a></span>(java.nio.channels.SocketChannel&nbsp;socketChannel,
    javax.net.ssl.SSLEngine&nbsp;engine)</code>&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../videostream/NioSslPeer.html#write-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-byte:A-">write</a></span>(java.nio.channels.SocketChannel&nbsp;socketChannel,
     javax.net.ssl.SSLEngine&nbsp;engine,
     byte[]&nbsp;message)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="myAppData">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>myAppData</h4>
<pre>protected&nbsp;java.nio.ByteBuffer myAppData</pre>
<div class="block">Will contain this peer's application data in plaintext, that will be
 later encrypted using <code>SSLEngine.wrap(ByteBuffer, ByteBuffer)</code> and
 sent to the other peer. This buffer can typically be of any size, as long
 as it is large enough to contain this peer's outgoing messages. If this
 peer tries to send a message bigger than buffer's capacity a
 <code>BufferOverflowException</code> will be thrown.</div>
</li>
</ul>
<a name="myNetData">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>myNetData</h4>
<pre>protected&nbsp;java.nio.ByteBuffer myNetData</pre>
<div class="block">Will contain this peer's encrypted data, that will be generated after
 <code>SSLEngine.wrap(ByteBuffer, ByteBuffer)</code> is applied on
 <a href="../videostream/NioSslPeer.html#myAppData"><code>myAppData</code></a>. It should be initialized using
 <code>SSLSession.getPacketBufferSize()</code>, which returns the size up to
 which, SSL/TLS packets will be generated from the engine under a session.
 All SSLEngine network buffers should be sized at least this large to
 avoid insufficient space problems when performing wrap and unwrap calls.</div>
</li>
</ul>
<a name="peerAppData">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peerAppData</h4>
<pre>protected&nbsp;java.nio.ByteBuffer peerAppData</pre>
<div class="block">Will contain the other peer's (decrypted) application data. It must be
 large enough to hold the application data from any peer. Can be
 initialized with <code>SSLSession.getApplicationBufferSize()</code> for an
 estimation of the other peer's application data and should be enlarged if
 this size is not enough.</div>
</li>
</ul>
<a name="peerNetData">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>peerNetData</h4>
<pre>protected&nbsp;java.nio.ByteBuffer peerNetData</pre>
<div class="block">Will contain the other peer's encrypted data. The SSL/TLS protocols
 specify that implementations should produce packets containing at most 16
 KB of plaintext, so a buffer sized to this value should normally cause no
 capacity problems. However, some implementations violate the
 specification and generate large records up to 32 KB. If the
 <code>SSLEngine.unwrap(ByteBuffer, ByteBuffer)</code> detects large inbound
 packets, the buffer sizes returned by SSLSession will be updated
 dynamically, so the this peer should check for overflow conditions and
 enlarge the buffer using the session's (updated) buffer size.</div>
</li>
</ul>
<a name="executor">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>executor</h4>
<pre>protected&nbsp;java.util.concurrent.ExecutorService executor</pre>
<div class="block">Will be used to execute tasks that may emerge during handshake in
 parallel with the server's main thread.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="NioSslPeer--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>NioSslPeer</h4>
<pre>public&nbsp;NioSslPeer()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="read-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>read</h4>
<pre>protected abstract&nbsp;void&nbsp;read(java.nio.channels.SocketChannel&nbsp;socketChannel,
                             javax.net.ssl.SSLEngine&nbsp;engine)
                      throws java.lang.Exception</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a name="write-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-byte:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>write</h4>
<pre>protected abstract&nbsp;void&nbsp;write(java.nio.channels.SocketChannel&nbsp;socketChannel,
                              javax.net.ssl.SSLEngine&nbsp;engine,
                              byte[]&nbsp;message)
                       throws java.lang.Exception</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a name="doHandshake-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doHandshake</h4>
<pre>protected&nbsp;boolean&nbsp;doHandshake(java.nio.channels.SocketChannel&nbsp;socketChannel,
                              javax.net.ssl.SSLEngine&nbsp;engine)
                       throws java.io.IOException</pre>
<div class="block">Implements the handshake protocol between two peers, required for the
 establishment of the SSL/TLS connection. During the handshake, encryption
 configuration information - such as the list of available cipher suites -
 will be exchanged and if the handshake is successful will lead to an
 established SSL/TLS session.

 <p/>
 A typical handshake will usually contain the following steps:

 <ul>
 <li>1. wrap: ClientHello</li>
 <li>2. unwrap: ServerHello/Cert/ServerHelloDone</li>
 <li>3. wrap: ClientKeyExchange</li>
 <li>4. wrap: ChangeCipherSpec</li>
 <li>5. wrap: Finished</li>
 <li>6. unwrap: ChangeCipherSpec</li>
 <li>7. unwrap: Finished</li>
 </ul>
 <p/>
 Handshake is also used during the end of the session, in order to
 properly close the connection between the two peers. A proper connection
 close will typically include the one peer sending a CLOSE message to
 another, and then wait for the other's CLOSE message to close the
 transport link. The other peer from his perspective would read a CLOSE
 message from his peer and then enter the handshake procedure to send his
 own CLOSE message as well.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>socketChannel</code> - - the socket channel that connects the two peers.</dd>
<dd><code>engine</code> - - the engine that will be used for encryption/decryption of
 the data exchanged with the other peer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if the connection handshake was successful or false if an
 error occurred.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - - if an error occurs during read/write to the socket
 channel.</dd>
</dl>
</li>
</ul>
<a name="enlargePacketBuffer-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enlargePacketBuffer</h4>
<pre>protected&nbsp;java.nio.ByteBuffer&nbsp;enlargePacketBuffer(javax.net.ssl.SSLEngine&nbsp;engine,
                                                  java.nio.ByteBuffer&nbsp;buffer)</pre>
</li>
</ul>
<a name="enlargeApplicationBuffer-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enlargeApplicationBuffer</h4>
<pre>protected&nbsp;java.nio.ByteBuffer&nbsp;enlargeApplicationBuffer(javax.net.ssl.SSLEngine&nbsp;engine,
                                                       java.nio.ByteBuffer&nbsp;buffer)</pre>
</li>
</ul>
<a name="enlargeBuffer-java.nio.ByteBuffer-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enlargeBuffer</h4>
<pre>protected&nbsp;java.nio.ByteBuffer&nbsp;enlargeBuffer(java.nio.ByteBuffer&nbsp;buffer,
                                            int&nbsp;sessionProposedCapacity)</pre>
<div class="block">Compares <code>sessionProposedCapacity<code> with buffer's capacity. If buffer's capacity is smaller,
 returns a buffer with the proposed capacity. If it's equal or larger, returns a buffer
 with capacity twice the size of the initial one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>buffer</code> - - the buffer to be enlarged.</dd>
<dd><code>sessionProposedCapacity</code> - - the minimum size of the new buffer,
 proposed by <code>SSLSession</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer with a larger capacity.</dd>
</dl>
</li>
</ul>
<a name="handleBufferUnderflow-javax.net.ssl.SSLEngine-java.nio.ByteBuffer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleBufferUnderflow</h4>
<pre>protected&nbsp;java.nio.ByteBuffer&nbsp;handleBufferUnderflow(javax.net.ssl.SSLEngine&nbsp;engine,
                                                    java.nio.ByteBuffer&nbsp;buffer)</pre>
<div class="block">Handles <code>SSLEngineResult.Status#BUFFER_UNDERFLOW</code>. Will check if
 the buffer is already filled, and if there is no space problem will
 return the same buffer, so the client tries to read again. If the buffer
 is already filled will try to enlarge the buffer either to session's
 proposed size or to a larger capacity. A buffer underflow can happen only
 after an unwrap, so the buffer will always be a peerNetData buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>buffer</code> - - will always be peerNetData buffer.</dd>
<dd><code>engine</code> - - the engine used for encryption/decryption of the data
 exchanged between the two peers.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The same buffer if there is no space problem or a new buffer with
 the same data but more space.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a name="closeConnection-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeConnection</h4>
<pre>protected&nbsp;void&nbsp;closeConnection(java.nio.channels.SocketChannel&nbsp;socketChannel,
                               javax.net.ssl.SSLEngine&nbsp;engine)
                        throws java.io.IOException</pre>
<div class="block">This method should be called when this peer wants to explicitly close the
 connection or when a close message has arrived from the other peer, in
 order to provide an orderly shutdown.
 <p/>
 It first calls <code>SSLEngine.closeOutbound()</code> which prepares this peer
 to send its own close message and sets <code>SSLEngine</code> to the
 <code>NEED_WRAP</code> state. Then, it delegates the exchange of close
 messages to the handshake method and finally, it closes socket channel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>socketChannel</code> - - the transport link used between the two peers.</dd>
<dd><code>engine</code> - - the engine used for encryption/decryption of the data
 exchanged between the two peers.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - if an I/O error occurs to the socket channel.</dd>
</dl>
</li>
</ul>
<a name="handleEndOfStream-java.nio.channels.SocketChannel-javax.net.ssl.SSLEngine-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleEndOfStream</h4>
<pre>protected&nbsp;void&nbsp;handleEndOfStream(java.nio.channels.SocketChannel&nbsp;socketChannel,
                                 javax.net.ssl.SSLEngine&nbsp;engine)
                          throws java.io.IOException</pre>
<div class="block">In addition to orderly shutdowns, an unorderly shutdown may occur, when
 the transport link (socket channel) is severed before close messages are
 exchanged. This may happen by getting an -1 or <code>IOException</code> when
 trying to read from the socket channel, or an <code>IOException</code> when
 trying to write to it. In both cases <code>SSLEngine.closeInbound()</code>
 should be called and then try to follow the standard procedure.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>socketChannel</code> - - the transport link used between the two peers.</dd>
<dd><code>engine</code> - - the engine used for encryption/decryption of the data
 exchanged between the two peers.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - if an I/O error occurs to the socket channel.</dd>
</dl>
</li>
</ul>
<a name="createKeyManagers-java.lang.String-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createKeyManagers</h4>
<pre>protected&nbsp;javax.net.ssl.KeyManager[]&nbsp;createKeyManagers(java.lang.String&nbsp;filepath,
                                                       java.lang.String&nbsp;keystorePassword,
                                                       java.lang.String&nbsp;keyPassword)
                                                throws java.lang.Exception</pre>
<div class="block">Creates the key managers required to initiate the <code>SSLContext</code>,
 using a JKS keystore as an input.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filepath</code> - - the path to the JKS keystore.</dd>
<dd><code>keystorePassword</code> - - the keystore's password.</dd>
<dd><code>keyPassword</code> - - the key's passsword.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>KeyManager</code> array that will be used to initiate the
 <code>SSLContext</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a name="createTrustManagers-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createTrustManagers</h4>
<pre>protected&nbsp;javax.net.ssl.TrustManager[]&nbsp;createTrustManagers(java.lang.String&nbsp;filepath,
                                                           java.lang.String&nbsp;keystorePassword)
                                                    throws java.lang.Exception</pre>
<div class="block">Creates the trust managers required to initiate the <code>SSLContext</code>,
 using a JKS keystore as an input.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filepath</code> - - the path to the JKS keystore.</dd>
<dd><code>keystorePassword</code> - - the keystore's password.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>TrustManager</code> array, that will be used to initiate the
 <code>SSLContext</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../videostream/package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../videostream/NioSslClient.html" title="class in videostream"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../videostream/NioSslServer.html" title="class in videostream"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../index.html?videostream/NioSslPeer.html" target="_top">Frames</a></li>
<li><a href="NioSslPeer.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
